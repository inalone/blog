---
title: "Aiko Log 1: The Reason & The Plan"
date: 2022-12-04T18:12:27Z
draft: false
tags: ["programming"]
---

Earlier this year, I wrote a blog post entitled [“State of Digital Music Playback”](posts/music/state-of-digital-playback/). Although more of a rant that should have been proof-read at least once, it at least highlights that I’ve been dissatisfied with open source music playback/library maintenance programs for years. This isn’t any form of shade, open source software is largely created to scratch a personal itch, with other people realising that they share the same itch and start contributing to or using the software that is provided to them for free, without warranty, with the source code completely available to them in full. It’s a system that works exceptionally well, and except for open source software created by or financially supported by corporations is a system of software created and maintained through love and good will. Open source solves problems by handing the power to individuals with a clear vision. However, a perfect music player/library maintenance program is one particular itch that I still need to be scratched. The clear vision of open source creators before me is one that doesn’t match my own.

This is not to say that open source music player/library maintenance programs do not exist. They do, some have existed with the same primary maintainer for decades and are generally well written, stable pieces of software that thousands of people use daily without issue. I also believe that the two main tasks at hand, playback and library maintenance, have been solved well in isolation. Playback isn’t anything special, you can use ffmpeg in a console to play back audio if you want to, and when it comes to tagging and directory structure, MusicBrainz Picard is powerful and effective, if a little slow... But the two combined has unfortunately only been solved perfectly by the devil… proprietary and Windows-first software!

The best examples of this are MusicBee and foobar2000, both of which are exceptional. They take different approaches to what a “comfortable” music player/library maintenance program should look and feel like, but both give you ultimate control over how you want to manage and display your music library, and in an exceptionally performant way. I especially love MusicBee, so much so that I am ashamed to admit that my main music player/library maintenance program currently is MusicBee, ran through WINE – a horrifically imperfect, yet generally “fine” experience. You can tag files and sort your library, but heaven forbid you click on the “File Converters” tab in preferences. 

So, in the open source spirit I have an itch to scratch, and have been attempting to scratch for years. This project has been through multiple phases over the past 4-5 years. Starting out as a C++ project with gtkmm, to a Python project with Qt, back to C++, a long detour to Rust, an equally long detour back to C++, another quick Python detour, and now back again to Rust. Yes I have decided on the hipster pragmatist’s language. The reasons are multiple – I want a compiled language, I want a language that handles various types of data well, I want a language that is flexible in what problems it is able to solve and I want an inherently stable final product. Wait, why the insistence on flexibility? Well, I have a scratch to itch, but am unsure on whether to use my fingernails or a fork – the fingernails in this case representing a friendly rest API which could theoretically connect to various types of clients meaning the possibility of a mobile app, web interface, native client and so forth, which also plays into my recent obsession with selfhosting software. Or we have the more reliable fork, a simple native GUI application that just does a bunch of SQLite queries and pretends it’s super smart for doing so.

But no matter if I choose the fingernail or the fork, I have to have… a… hand. The hand being self-made friendly APIs to last.fm, Discogs and music tags. I will catalogue my journey through these APIs and making ergonomic, fast APIs for them in later blog posts - don't get too excited!

I think some attempt to justify why I need this software isn’t really worth it because it’s something I’ve wanted to do properly for years, but I hope codifying this journey through fingernails, forks and hands will motivate me into tackling some genuinely tough programming problems head-on and persisting through them rather than giving up at any major hurdle and not being scared to reinvent the wheel when the pre-existing wheel is shit.

The program, no matter what, will be called aiko – named after the main singer of Japanese indie-pop band advantage Lucy, a band whose relative obscurity has slowly been reversing over the years due to its dedicated fanbase showing people how excellent their music really is – I admittedly am one of those preachers, with several successful conversions under my belt. The idea to name your music playback/library maintenance program after an artist isn’t especially new, the Linux-first music playback/library maintenance program called Strawberry was named after Strawbs, but I just really love advantage Lucy and I’m horrifically uncreative so aiko it is.

I hope to see aiko through to the end – the MVP isn’t going to be a strict set of criteria, but will instead be my comfort and sense of achievement with the end-product. These blog posts I'll make about aiko may be extremely dry to the point of not being particularly fun to read, but they’ll at least document some really interesting programming problems I’m going to face, as well as some overarching structural decisions you have to make when you make software, such as if a fingernail or a fork is going to be more satisfying of an itch-scratcher.